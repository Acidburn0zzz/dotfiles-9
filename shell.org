#+TITLE: My Shell Configuration

* .bash_profile
:PROPERTIES:
:header-args: :tangle ~/.bash_profile
:END:

#+BEGIN_SRC shell
source ~/.bashrc
#+END_SRC

* .bashrc
:PROPERTIES:
:header-args: :tangle ~/.zshrc
:END:

Make sure that whenever I look at my =~/.bashrc= I remember that it's been generated by emacs!

#+BEGIN_SRC shell
###### HEY BUDDY, DON'T FORGET THAT THIS FILE HAS BEEN AUTOGENERATED!!! ######
#+END_SRC

** Sensible Defaults

*** Better, Longer History

Set the bash history to use =.bash_history=:

#+BEGIN_SRC shell
  HISTFILE=~/.bash_history
#+END_SRC

Make the history size and saved history 10k commands:

#+BEGIN_SRC shell
  HISTSIZE=10000
  SAVEHIST=10000
#+END_SRC

*** Colors

Detect which =ls= flavor is in use and set the proper colorflag for later:
#+BEGIN_SRC shell
  if ls --color > /dev/null 2>&1; then # GNU `ls`
    colorflag="--color"
  else # OS X `ls`
    colorflag="-G"
  fi
#+END_SRC

** Aliases

I like to easily move up through my directory tree in my shell, make it so I can go up to four directories up with just n+1 =.=:
#+BEGIN_SRC shell 
  alias ..="cd ../"
  alias ...="cd ../../"
  alias ....="cd ../../../"
  alias .....="cd ../../../../"
#+END_SRC

Create shorter aliases for "ls" and use colorflag so it prints out more colorfully:
#+BEGIN_SRC shell
  alias l="ls -l ${colorflag}"
  alias la="ls -la ${colorflag}"
  alias lsd='ls -l ${colorflag} | grep "^d"'
  alias ls="command ls ${colorflag}"
  export LS_COLORS='no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.avi=01;35:*.fli=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.ogg=01;35:*.mp3=01;35:*.wav=01;35:'
#+END_SRC

Create a shortcut to get to dotfiles:
#+BEGIN_SRC shell 
  alias dotfiles="cd $HOME/src/gitlab.com/chaseadamsio/dotfiles"
#+END_SRC

Make it easy to reload my =.bash_profile= from the command line:
#+BEGIN_SRC shell
  alias re!=". $HOME/.bash_profile"
#+END_SRC

*** Docker 

stop all running docker containers:
#+BEGIN_SRC shell
  alias dockerstopall="docker stop $(docker ps -a -q)"
#+END_SRC

remove all running docker containers:
#+BEGIN_SRC shell
  alias dockerrmall="docker rm $(docker ps -a -q)"
#+END_SRC

nuke all running docker containers:
#+BEGIN_SRC shell
  alias dockernukeall="dockerstopall && dockerrmall"
#+END_SRC

*** OSX

Sometimes the daemon for the built-in cameras on OSX gets in a weird state and the camera no longer works. This restarts the daemon and fixes the camera issue:

#+BEGIN_SRC shell
alias fixcamera="sudo killall VDCAssistant"
#+END_SRC

** Functions

=mkdir= recursively /and/ change into it when done:
#+BEGIN_SRC shell
  mkd() {
    mkdir -p "$@" && cd "$@"
  }
#+END_SRC

=gogithub= runs =go get= for the argument passed in, forks it to your Github remote, and adds the remote for your fork as =origin= and updates the =go get= remote to =upstream=.

Usage:
#+BEGIN_EXAMPLE
  gogithub git@github.com/golang/go chaseadamsio $MY_GITHUB_TOKEN
#+END_EXAMPLE

#+BEGIN_SRC shell
  gogithub() {
      regex="git@([a-zA-Z0-9.]+):(.*)/(.*).git"
      upstream_remote=$1
      user=$2
      user_token=$3

      if [[ $upstream_remote =~ $regex ]]; then
          remote_root=${BASH_REMATCH[1]} 
          if [[ $remote_root == "github.com" ]]; then
              api_root="https://api.github.com"
          else
              api_root="https://${remote_root}/api/v3"
          fi
          
          upstream_owner=${BASH_REMATCH[2]} 
          repo=${BASH_REMATCH[3]}

          project_path=$GOPATH/src/$remote_root/$upstream_owner
          user_remote="git@${remote_root}:${user}/$repo"

          mkdir -p $project_path 

          git clone $1 --origin upstream $project_path/$repo

          api_endpoint=$api_root/repos/$user/$repo

          status_code=$(curl -s \
                             -H "Authorization: token $user_token" \
                             -o /dev/null -w "%{http_code}" \
                             $api_endpoint)

          if [ 300 -gt $status_code ]; then
              echo "fork already exists"
              return 1 
          else
              api_endpoint=$api_root/repos/$upstream_owner/$repo/forks
              echo $api_endpoint
              status_code=$(curl -s \
                                 -X POST \
                                 -H "Authorization: token $user_token" \
                                 -o /dev/null -w "%{http_code}" \
                                 $api_endpoint) 

              if [ 202 -eq $status_code ]; then
                  echo "successfully forked ${upstream_owner}/${repo}"
              else
                  echo "${status_code} unable to fork ${upstream_owner}/${repo}"
              fi
          fi

          cd $project_path/$repo

          git remote add origin $user_remote
      else
          echo "unable to determine the URL for the Github project you're trying to get."
          exit 1
      fi
  }
#+END_SRC

An alias for using =gogithub= for public github:
#+BEGIN_SRC shell
  ggh() {
      gogithub $1 $GH_USER $GH_TOKEN
  }
#+END_SRC

An alias for using =gogithub= for enterprise github:
#+BEGIN_SRC shell
  gghe() {
      gogithub $1 $GHE_USER $GHE_TOKEN
  }
#+END_SRC

=git-branch-nuke= deletes a branch locally and in the origin remote:
#+BEGIN_SRC shell
  git-branch-nuke() {
      git branch -D $1
      git push origin :$1    
  }
#+END_SRC

** Exports

Setup the =$GOPATH=, =$WRK= and add =go= things to the =$PATH=:
#+BEGIN_SRC shell
  export GOPATH=$HOME
  export WRK=$GOPATH/src
  export PATH=$GOPATH/bin:/usr/local/go/bin:$PATH
#+END_SRC

** Everything else...

#+BEGIN_SRC shell
  if [[ -a ~/bin/git-completion.zsh ]]
  then
     source ~/bin/git-completion.zsh
  fi
#+END_SRC

If there's a =.localrc= (with things that shouldn't be version controlled or are unique to a specific machine, source it:

#+BEGIN_SRC shell
  if [[ -a ~/.localrc ]] 
  then
    source ~/.localrc
  fi
#+END_SRC

